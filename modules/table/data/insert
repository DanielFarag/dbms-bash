#!/bin/bash

insert_table_records(){
    local content=$(sed -n '$p' $(CURRENT_TABLE_DATA_PATH))  

    local columns=($(fetch_table_columns))

    local newRecord=()
    
    local length="${#columns[@]}"
    local current=0



    title "Create New Record $CURRENT_TABLE in ($CURRENT_DB)"
    while (( current != length  )); do
        IFS=':' read -r column type pk <<< "${columns[$current]}"

        local default_value=""

        prompt="$column ($type)"
        
        local pk_value=""
        if [[ "$pk" == "primary_key" && "$type" == "int" ]]; then
            pk_value="$(get_latest_id)"
            prompt+=" [$pk_value]"
        fi

        read -p "$prompt : " default_value

        if [[ -z "$default_value" &&  ! -z "$pk_value" ]]; then
            default_value="$pk_value"
        fi


        if [[ -z "$default_value" ]]; then
            loading "Value cannot be empty!"
            continue
        fi

        if [[ "$type" == "int" && ! $default_value =~ ^[0-9]+$ ]]; then
            loading "Value must be integer!"
            continue
        fi

        if [[ "$type" == "string" && ! $default_value =~ ^[A-Za-z0-9\ ]+$ ]]; then
            loading "Value must be alphanmeric string [spaces allowed]!"
            continue
        fi

        if [[ "$pk" == "primary_key" ]]; then
            pk_key="$(get_primary_key)"
            data=($(get_rows_by_keys "$pk_key=$default_value"))
            if [[ "${#data[@]}" -ne "0" ]]; then
                loading "Primary Key must be unique!"
                continue
            fi

        fi

        ((current++))

        newRecord+=("$default_value")
    done

    if (( length  != current )); then
        return
    fi

    loading "New Record Inserted (${newRecord[*]})"

    IFS=":"  
    echo "${newRecord[*]}" >> $(CURRENT_TABLE_DATA_PATH)
    unset IFS
}
